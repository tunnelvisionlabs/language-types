// Copyright (c) Tunnel Vision Laboratories, LLC. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

namespace TunnelVisionLabs.LanguageTypes.SourceGenerator
{
    using Microsoft.CodeAnalysis;

    [Generator(LanguageNames.CSharp)]
    internal class IsExternalInitSourceGenerator : IIncrementalGenerator
    {
        private const string IsExternalInitSource = @"// <auto-generated/>

#nullable enable

namespace System.Runtime.CompilerServices
{
    using System.ComponentModel;

    /// <summary>
    /// Reserved to be used by the compiler for tracking metadata.
    /// This class should not be used by developers in source code.
    /// </summary>
    [EditorBrowsable(EditorBrowsableState.Never)]
    internal static class IsExternalInit
    {
    }
}
";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var referencedTypesData = context.CompilationProvider.Select(
                (compilation, cancellationToken) =>
                {
                    var hasIsExternalInit = IsCompilerTypeAvailable(compilation, "System.Runtime.CompilerServices.IsExternalInit");

                    return new ReferencedTypesData(
                        HasIsExternalInit: hasIsExternalInit);
                });

            context.RegisterSourceOutput(
                referencedTypesData,
                (context, referencedTypesData) =>
                {
                    var forwarders = new List<string>();

                    if (referencedTypesData.HasIsExternalInit == TypeDefinitionLocation.None)
                    {
                        context.AddSource("IsExternalInit.g.cs", IsExternalInitSource.ReplaceLineEndings("\r\n"));
                    }
                    else if (referencedTypesData.HasIsExternalInit == TypeDefinitionLocation.Referenced)
                    {
                        forwarders.Add("IsExternalInit");
                    }

                    if (forwarders.Count > 0)
                    {
                        var compilerForwarders = $@"// <auto-generated/>

#nullable enable

using System.Runtime.CompilerServices;

{string.Join("\r\n", forwarders.Select(forwarder => $"[assembly: TypeForwardedTo(typeof({forwarder}))]"))}
";

                        context.AddSource("CompilerForwarders.g.cs", compilerForwarders.ReplaceLineEndings("\r\n"));
                    }
                });
        }

        private static TypeDefinitionLocation IsCompilerTypeAvailable(Compilation compilation, string fullyQualifiedMetadataName)
        {
            return compilation.GetBestTypeByMetadataName(fullyQualifiedMetadataName, requiresAccess: true) switch
            {
                { OriginalDefinition.ContainingAssembly: var containingAssembly } when SymbolEqualityComparer.Default.Equals(compilation.Assembly, containingAssembly) => TypeDefinitionLocation.Defined,
                { } => TypeDefinitionLocation.Referenced,
                _ => TypeDefinitionLocation.None,
            };
        }

        private sealed record ReferencedTypesData(
            TypeDefinitionLocation HasIsExternalInit);
    }
}
